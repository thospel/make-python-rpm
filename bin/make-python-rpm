#!/usr/bin/env python3
import sys
import re
import os
import errno
import subprocess
import shlex
import shutil
import getpass
import pwd
import platform
import socket
from datetime import datetime
from pathlib import Path
from string import Template
from collections import ChainMap
from stat import S_IXUSR
from setuptools.dist import Distribution
from dataclasses import dataclass, field
from typing import Dict, List, Set, Tuple, Optional, ClassVar
# We want this to work in plain python without external modules
# So avoid docopt
import argparse

# This number will automatically get replaced by make-python-rpm
PACKAGE_VERSION = "1.0.0"

DIST = Distribution()
DIST.parse_config_files()
# pprint(DIST.install_requires)

RPM	= "rpm"
DEB	= "deb"

TEMPLATE_DIR  = Path(__file__).parents[1] / "etc" / "make-python-rpm"
TEMPLATE_FILE = str(TEMPLATE_DIR / "spec.tmpl")
ORGANIZATION_DIR = "/usr/local/lib"
VENDOR = "%s <%s>" % (DIST.get_contact(), DIST.get_contact_email())	# type: ignore[attr-defined]
TARGET = "%s/%s" % (ORGANIZATION_DIR, DIST.get_name())	# type: ignore[attr-defined]
GROUP  = "Development/Libraries"
FULL   = "-full"

DEBIAN_VERSION = "/etc/debian_version"

defaults = {
    "format":	RPM,
    "target":   TARGET,
    "git":      "",
    "template": TEMPLATE_FILE,
    "group":    GROUP,
    "vendor":   VENDOR,
    "version_min": None,
    "executable": None
}

for name in defaults:
    try:
        defaults[name] = DIST.command_options["make_python_rpm"][name][1]	# type: ignore[attr-defined]
    except KeyError:
        pass

class MakeChainMap(ChainMap):
    def __getitem__(self, key):
        """Escape $ in all values to $$"""
        return super().__getitem__(key).replace("$", "$$")

SENTINEL_DICT: Dict[str, str] = {}
class AtTemplate(Template):
    """A Template subclass that uses @ as delimiter"""
    delimiter = "@"

class MakeTemplate(AtTemplate):
    """A Template subclass that uses @ as delimiter and replaces $ by $$ in all substituted value"""
    def substitute(self, mapping=SENTINEL_DICT, **kws):
        """Escape % in all substituted values to %%"""
        if mapping is SENTINEL_DICT:
            mapping = MakeChainMap(kws)
        elif kws:
            mapping = MakeChainMap(kws, mapping)
        else:
            mapping = MakeChainMap(mapping)
        return super().substitute(mapping)

class SpecChainMap(ChainMap):
    def __getitem__(self, key):
        """Escape % in all values to %%"""
        return super().__getitem__(key).replace("%", "%%")

class SpecTemplate(AtTemplate):
    """A Template subclass that uses @ as delimiter and replaces % by %% in all substituted value"""
    def substitute(self, mapping=SENTINEL_DICT, **kws):
        """Escape % in all substituted values to %%"""
        if mapping is SENTINEL_DICT:
            mapping = SpecChainMap(kws)
        elif kws:
            mapping = SpecChainMap(kws, mapping)
        else:
            mapping = SpecChainMap(mapping)
        return super().substitute(mapping)

def run(*args: str,
        expect_error: Set[str] = None,
        expect_returncode: Set[int] = None,
        capture_output: bool = True) -> str:
    """Run an external program and returns its output but only if there is no
    error output and no unexpected exitcode. Otherwise raise an exception
    """
    if expect_returncode is None:
        expect_returncode = { 0 }
    args = (*args[0].split(), *args[1:])
    command = " ".join(args)
    print("+", command)
    if capture_output:
        result = subprocess.run(args,
                                stdout = subprocess.PIPE,
                                stderr = subprocess.PIPE,
                                universal_newlines = True)
    else:
        result = subprocess.run(args, universal_newlines = True)
    if capture_output:
        error = result.stderr.strip()
        if expect_error is not None:
            if error not in expect_error:
                raise SystemExit(f"Unexpected error from {command!r}: {error!r}")
        elif error:
            raise SystemExit("Error from '%s': %s" % (command, error))
    if result.returncode not in expect_returncode:
        if result.returncode < 0:
            raise SystemExit("'%s' killed by signal %d" %
                             (command, -result.returncode))
        elif result.returncode == 0:
            raise ValueError("'%s' unexpectedly succeeded", command)
        else:
            raise SystemExit("'%s' exited with unexpected returncode %d" %
                             (command, result.returncode))
    return result.stdout

def git_describe() -> Tuple[str, str, str]:
    """Runs 'git describe --long'

    Returns:
        A tuple of strings: `(version, commit_nr, id)`
    """
    tag = run("git describe --long")
    match = re.fullmatch(r"v(.*)-(\d+)-g([0-9a-fA-F]+)\n", tag, re.ASCII)
    if not match:
        raise SystemExit("Cannot parse 'git describe --long' output '%s'" % tag)
    return match[1], match[2], match[3]

def git_branch() -> str:
    """Determine the current git branch

    Returns:
        A the current branch or the empty string if it can't determine it
    """
    branch = run("git symbolic-ref -q HEAD", expect_returncode = {0, 1})
    if branch:
        # We could avoid this using the --short option to git symbolic-ref
        # However that doesn't exist on very old git versions like 1.7.7.6
        if not branch.endswith("\n"):
            raise AssertionError("Git symbolic ref '%s' does not end with '\n'" % branch)
        branch = branch[:-1]
        if not branch.startswith("refs/heads/"):
            raise AssertionError("Git symbolic ref '%s' does not start with 'refs/heads/'" % branch)
        branch = branch[11:]
    return branch

def info_from_package_rpm(rpm_package: str, must_exist = True) -> Dict[str, str]:
    """Return info of a given package"""

    cmd_info = ["rpm", "-qi", "--", rpm_package]
    if must_exist:
        rpm_info = run(*cmd_info)
    else:
        rpm_info = run(*cmd_info, expect_returncode = { 0, 1 })
    if not must_exist:
        if rpm_info.strip() == "package %s is not installed" % rpm_package:
            return {}
    match = re.fullmatch(r"""
    (
    (?:
    ^                        # Start a new line
    [A-Z] [^\n:]* [^\s:]     # Key
    [^\S\n] * : [ ]          # Separator
    .* \n                    # Value
    )+?
    )
    Description\s* :         # Final key
    ([^\0]*)                 # Final value
    """, rpm_info, flags = re.ASCII | re.MULTILINE | re.VERBOSE)
    if not match:
        raise ValueError("Cannot parse output of rpm -qi -- %s" % rpm_package)
    description = match.group(2).strip()
    key_values = re.split(r"""
    (^ [A-Z] [^\n:]* [^\s:]) # Key
    [^\S\n] * : [ ]          # Separator
    """, match.group(1), flags = re.ASCII | re.MULTILINE | re.VERBOSE)
    # The previous fullmatch forces the result to be an empty string
    # followed by key/value pairs
    # print(key_values)
    if len(key_values) % 2 == 0:
        raise AssertionError("Not an even number of properties")
    key_values.extend((
        "description", description,
    ))
    iter = (s for s in key_values)
    if next(iter) != "":
        raise AssertionError("First element is not empty")
    # Convert keys to lowercase and replace whitespace by _
    keys = ("_".join(key.split()).casefold() for key in iter)
    # Strip leading and trailing spaces from values
    values = (value.strip() for value in iter)
    return dict(zip(keys, values))

def info_from_package_deb(deb_package: str, must_exist = True) -> Dict[str, str]:
    """Return info of a given package"""
    cmd_info = ["dpkg-query", "-f", "Name: ${binary:Package}\\nVersion: ${Version}\\nArchitecture: ${Architecture}\\nURL: ${Homepage}\\nSection: ${Section}\\nVendor: ${Maintainer}\\nSize: ${Size}\\nDescription: ${Description}\n",
                "-W", deb_package]
    if must_exist:
        deb_info = run(*cmd_info)
    else:
        deb_info = run(*cmd_info,
                       expect_returncode = { 0, 1 },
                       expect_error = { "", "dpkg-query: no packages found matching %s" % deb_package })
        if not deb_info:
            return {}
    match = re.fullmatch(r"""
    (
    (?:
    ^                        # Start a new line
    [A-Z] [^\n:]* [^\s:]     # Key
    [^\S\n] * : [ ]          # Separator
    .* \n                    # Value
    )+?
    )
    Description\s* :         # Final key
    ([^\0]*)                 # Final value
    """, deb_info, flags = re.ASCII | re.MULTILINE | re.VERBOSE)
    if not match:
        raise ValueError("Cannot parse output of dpkg-query -W -- %s" % deb_package)
    description = match.group(2).strip()
    key_values = re.split(r"""
    (^ [A-Z] [^\n:]* [^\s:]) # Key
    [^\S\n] * : [ ]          # Separator
    """, match.group(1), flags = re.ASCII | re.MULTILINE | re.VERBOSE)
    # The previous fullmatch forces the result to be an empty string
    # followed by key/value pairs
    # print(key_values)
    if len(key_values) % 2 == 0:
        raise AssertionError("Not an even number of properties")
    key_values.extend((
        "description", description,
    ))
    iter = (s for s in key_values)
    if next(iter) != "":
        raise AssertionError("First element is not empty")
    # Convert keys to lowercase and replace whitespace by _
    keys = ("_".join(key.split()).casefold() for key in iter)
    # Strip leading and trailing spaces from values
    values = (value.strip() for value in iter)
    info = dict(zip(keys, values))
    # Debian versions are of the form
    # [epoch:]upstream_version[-debian_revision]
    # Here we split off the debian_revision as release
    info["version"], _, info["release"] = info["version"].partition("-")
    return info

def package_from_file(path: str, format: str = RPM) -> Dict[str, str]:
    """Given a path determine which RPM package that file comes from and return
    the properties of that package
    """

    real_path = os.path.realpath(path)
    if format == RPM:
        package = run("rpm", "-qf", "--", real_path).strip()
        info = info_from_package_rpm(package)
    elif format == DEB:
        dpkg_out = run("dpkg", "-S", "--", real_path).strip()
        package, colon, _ = dpkg_out.partition(":")
        if colon != ":":
            raise AssertionError("Could not find colon in dpkg output '%s'", dpkg_out)
        info = info_from_package_deb(package)
    else:
        raise AssertionError("Unhandled package format '%s'" % format)

    info.update({
        # Initial _ makes certain it can't be overwritten by a package property
        "_package": package,
        "_path": path,
        "_path_shell": shlex.quote(path),
        "_path_real": real_path,
        "_path_real_shell": shlex.quote(real_path),
    })
    return info

def get_pwd() -> pwd.struct_passwd:
    """return the password entry for the current user (based on environment variables)"""
    name = getpass.getuser()
    return pwd.getpwnam(name)

def real_home() -> str:
    """Get real path of user home directory based on effective uid (ignoring environment)"""
    return os.path.realpath(pwd.getpwuid(os.geteuid()).pw_dir)

def make_rpm(package_dir: Path,
             dist_dir: Path,
             spec_file: Path,
             package_variables: Dict[str, str]) -> None:
    for dir in "RPMS", "SRPMS":
        os.mkdir("%s/%s" % (package_dir, dir))

    run("rpmbuild", "-ba",
        "--define", "debug_package %{nil}",
        "--define", "__python python3",
        "--define", "_topdir %s" % package_dir.resolve(),
        "--clean",
        str(spec_file),
        capture_output = False)

    found = 0
    rpm_dir = package_dir / "SRPMS"
    for rpm in rpm_dir.iterdir():
        if rpm.suffix.casefold() != ".rpm":
            continue
        if not rpm.is_file():
            raise(ValueError("Path '%s' is not a file" % rpm))
        shutil.copy(rpm, dist_dir)
        print("Created", dist_dir / rpm.name)
        found += 1
    if not found:
        raise ValueError(f"No valid rpm  in {rpm_dir}")

    found = 0
    rpm_dir = package_dir / "RPMS" / package_variables["architecture"]
    for rpm in rpm_dir.iterdir():
        if rpm.suffix.casefold() != ".rpm":
            continue
        if not rpm.is_file():
            raise(ValueError("Path '%s' is not a file" % rpm))
        shutil.copy(rpm, dist_dir)
        print("Created", dist_dir / rpm.name)
        found += 1
    if not found:
        raise ValueError(f"No valid rpm  in {rpm_dir}")

# Extremely simplified RPM spec file parser
@dataclass
class Spec:
    BASE_SECTION: ClassVar[str] = "base"

    spec_file: Path
    sections: Dict[str, List[str]] = field(init = False, default_factory = dict)
    settings: Dict[str, str] = field(init = False, default_factory = dict)

    def __post_init__(self):
        with open(DEBIAN_VERSION) as version_file:
            # E.g. get `sid` from `bookworm/sid`
            # distribution = next(version_file)strip().split("/", maxsplit=1)[0]
            distribution = next(version_file).strip().split("/", maxsplit=2)[1]
        now = datetime.now().astimezone()
        variables: Dict[str, str] = dict(
            date	= now.strftime("%a, %d %b %Y %H:%M:%S %z"),
            user	= getpass.getuser(),
            fqdn	= socket.getfqdn(),
            script_name = str(Path(sys.argv[0]).name),
            distribution= distribution,
        )

        section_name = self.BASE_SECTION
        self.sections[section_name] = []

        def substitute(match: re.Match):
            if match[1] is None:
                return "%"
            if match[1].startswith(("?", "_")):
                return "Unimplemented"
            return variables[match[1]]

        with open(self.spec_file) as handle:
            for line in handle:
                line = re.sub(r"%(?:%|\{([^{}]*)\})", substitute, line.rstrip())
                if match := re.match(r"%(\w+)(\s+|$|(?=\())", line):
                    if match[1] == "define":
                        _, name, value = line.split(maxsplit = 2)
                        variables[name] = value
                    elif match[1] in ("description", "prep", "build", "install", "check", "clean", "post", "preun"):
                        section_name = match[1]
                        if section_name in self.sections:
                            raise RuntimeError(f"Duplicate section {section_name!r}")
                        self.sections[section_name] = []
                    elif match[1] in ("setup", "files", "defattr"):
                        # Directive we (currently) ignore
                        pass
                    else:
                        raise NotImplementedError(f"{match=}")
                    continue
                # Remove leading empty lines
                if line or self.sections[section_name]:
                    self.sections[section_name].append(line)

        # Remove trailing empty lines
        for section in self.sections.values():
            while section and not section[-1]:
                section.pop()

        self.settings = variables
        for line in self.sections[self.BASE_SECTION]:
            line = line.strip()
            if not line or line.startswith("#"):
                continue
            match = re.fullmatch(r"^(\w+):\s*(.*)", line)
            if not match:
                raise RuntimeError("Cannot parse base section {line=}")
            self.settings[match[1]] = match[2]

        for section_name, section in self.sections.items():
            if section_name == self.BASE_SECTION:
                continue
            self.settings[section_name] = "\n".join("\t%s" % line if line else "" for line in section)
        # print(self.settings)

    def print_sections(self):
        print("Settings", self.settings)
        for section, lines in self.sections.items():
            if section == self.BASE_SECTION:
                continue
            print(f"{section=}\n============")
            for line in lines:
                print(line)

    def make_debian(self, debian_dir: Path, templates: Path):
        debian_dir.mkdir()
        for file in templates.glob("*.tmpl"):
            if file.name.startswith("."):
                continue
            template_class = MakeTemplate if file.stem == "rules" else AtTemplate
            template = template_class(file.read_text())
            try:
                output = template.substitute(self.settings)
            except KeyError as exc:
                print(f"Not generating debian/{file.stem} (no variable named {exc})")
                continue

            executable = file.stat().st_mode & S_IXUSR != 0
            output_file = debian_dir / file.stem
            with open(os.open(output_file, os.O_CREAT | os.O_WRONLY, 0o777 if executable else 0o666), "w") as output_handle:
                output_handle.write(output)

def make_deb(package_dir: Path,
             dist_dir: Path,
             spec_file: Path,
             templates: Path,
             package_variables: Dict[str, str]) -> None:
    spec = Spec(spec_file)
    # spec.print_sections()

    build_dir = package_dir / "BUILD"
    sources_dir = package_dir / "SOURCES"
    run("tar", "-C", str(build_dir), "-xf", str(sources_dir / package_variables["source"]))
    tar_dirs = list(build_dir.iterdir())
    if len(tar_dirs) != 1:
        raise AssertionError(f"Expected exectly 1 direcroy in tar file, got {tar_dirs!r}")
    deb_dir = tar_dirs[0]
    spec.make_debian(deb_dir / "debian", templates)
    command = "debuild -i -us -uc -b"
    result = subprocess.run(command.split(), cwd = deb_dir)
    if result.returncode:
        raise SystemExit("'%s' exited with unexpected returncode %d" %
                         (command, result.returncode))
    for deb in build_dir.iterdir():
        if deb.suffix.casefold() != ".deb":
            continue
        if not deb.is_file():
            raise(ValueError("Path '%s' is not a file" % deb))
        shutil.copy(deb, dist_dir)
        print("Created", dist_dir / deb.name)

def full_package(
        format: str = RPM,
        target: str = TARGET,
        template: str = TEMPLATE_FILE,
        git: str = "",
        release: int = None,
        group: str = GROUP,
        vendor: str = VENDOR,
        executable: Optional[str] = None,
        spec_only: bool = False,
        version_min: Optional[str] = None,
        debug: bool = False) -> None:

    if os.geteuid() == 0:
        raise SystemExit("Please do not run this script as user root")

    if sys.version_info < (3, 8):
        raise SystemExit("Python 3.8 or later is required")

    if version_min:
        from pkg_resources import packaging	# type: ignore[attr-defined]
        Version = packaging.version.Version
        # from packaging.version import Version
        if Version(version_min) > Version(PACKAGE_VERSION):
            raise SystemExit(f"Version check failed: {version_min} > {PACKAGE_VERSION}")
        if debug:
            print(f"Version check succeeded: {version_min} <= {PACKAGE_VERSION}")

    version = DIST.get_version()	# type: ignore[attr-defined]

    if git:
        # Check git branch
        branch = git_branch()
        if not branch:
            raise SystemExit("I could not determine your git branch. You may be in a detached HEAD state")
        if branch != git:
            raise SystemExit("You are on git branch '%s'. But I will only generate an RPM for branch '%s'" % (branch, git))

        # Determine patch number
        (git_version, nr_commits, _) = git_describe()
        if version != git_version:
            raise SystemExit("Inconsistent version. Your setup.py says '%s' but git describe says '%s'" % (version, git_version))
        patch = "." + nr_commits
        version += patch
        # The extra `0` is a horrible, horrible hack. If the patch is equal to
        # the last component of the version it is ignored by `egg_info -b`. E.g.
        # version `1.2` with -b 2 will lead to version `1.2` instead of the
        # proper `1.2.2`. It properly works however with -b 02. Go figure...
        patch = ".0" + nr_commits
    else:
        patch = ""

    home = real_home()
    python_unwrapped = sys.executable
    while True:
        dir_unwrapped = os.path.realpath(os.path.dirname(python_unwrapped))
        if os.path.commonpath((home, dir_unwrapped)) != home:
            break
        try:
            link = os.readlink(python_unwrapped)
        except OSError as e:
            if e.errno != errno.EINVAL:
                raise
            raise SystemExit("You are running this script with python executable '%s' which in the end points to '%s' which in turn is inside your home directory '%s'. I will not create an package based on a private python version" % (sys.executable, python_unwrapped, home)) from None
        python_unwrapped = python_unwrapped = os.path.join(dir_unwrapped, link)
    if python_unwrapped != sys.executable:
        print("You are probably running inside a virtual environment. I followed some symlinks and will use '%s' is the target python" % python_unwrapped)
    python_package = package_from_file(python_unwrapped, format = format)

    # We probably don't really need to add pip in the dependencies
    # E.g. the whole rpm build can be done using a pip from PYPI
    # It's just that I don't want to leave a system with an implicitely
    # installed python without corresponding pip
    pip_file = run(python_package["_path_real"], "-c", """
import sys
import pip
print(sys.modules["pip"].__file__)
    """).strip()
    # We should probably handle the case that there is no pip package...
    pip_package = package_from_file(pip_file, format = format)
    # We should probably handle the case that the python and pip package are the same...

    # DIST.parse_command_line()

    # Add suffix -full to indicate that it has all dependencies and differs
    # from what bdist_rpm generates
    package_name = DIST.get_name() + FULL	# type: ignore[attr-defined]
    package_version = version.replace("-", "_")
    architecture = python_package["architecture"]
    license = DIST.get_license() or "UNKNOWN"	# type: ignore[attr-defined]
    # If no explicit license try to get it from a classifier
    if license.casefold() == "unknown":
        for classifier in DIST.get_classifiers():	# type: ignore[attr-defined]
            match = re.fullmatch(r"^License\s*::\s*(\S.*)", classifier, re.IGNORECASE)
            if match:
                license = match.group(1).rstrip()
                break
    if release is None:
        if format == RPM:
            old_package = info_from_package_rpm(
                "%s-%s" % (package_name, package_version),
                must_exist = False)
        elif format == DEB:
            old_package = info_from_package_deb(
                "%s" % package_name,
                must_exist = False)
            if old_package and old_package["version"] != package_version:
                old_package = {}
        else:
            raise AssertionError("Unhandled package format '%s'" % format)

        if old_package:
            release = 1 + int(old_package["release"])
        else:
            release = 1

    scripts: List[str] = []
    for script in DIST.command_options["options"]["scripts"]:	# type: ignore[attr-defined]
        script = script.strip()
        if not script.startswith("bin/"):
            continue
        if "/" in script[4:]:
            continue
        scripts.append(script)

    dist_dir = Path("dist")
    dist_dir.mkdir(parents = True, exist_ok = True)

    build_dir = Path("build/full_package.%s" % platform.platform(aliased = True, terse = True))
    build_dir.mkdir(parents = True, exist_ok=True)
    shutil.rmtree(build_dir)
    os.umask(0o22)
    build_dir.mkdir()
    package_dir = build_dir / format
    package_dir.mkdir()

    for dir in "SOURCES", "SPECS", "BUILD":
        (package_dir / dir).mkdir()

    source_dir = package_dir / "SOURCES"
    force_version = ["egg_info", "-b", patch, "-e", str(build_dir)] if patch else []
    run(python_unwrapped,
        "setup.py", *force_version, "sdist", "--dist-dir", str(source_dir),
        capture_output = False)
    sources = source_dir.iterdir()
    source = next(sources)
    if not source.is_file():
        raise(ValueError("sdist result '%s' is not a file" % source))
    extra = next(sources, None)
    if extra is not None:
        raise(ValueError("Spurious sdist result '%s'" % extra))
    if executable is None:
        executable = ""

    package_variables: Dict[str, str] = dict(
        name          = DIST.get_name(),	# type: ignore[attr-defined]
        version       = version,
        package_name  = package_name,
        package_version = package_version,
        release       = str(release),
        architecture  = architecture,
        description   = DIST.get_description(),	# type: ignore[attr-defined]
        long_description = DIST.get_long_description().strip(),	# type: ignore[attr-defined]
        group         = group,
        license       = license,
        vendor        = vendor,
        packager      = get_pwd().pw_gecos,
        source        = source.name,
        URL           = DIST.get_url(),	# type: ignore[attr-defined]
        requires      = ", ".join([python_package["name"], pip_package["name"]]),
        python_shell  = python_package["_path_shell"],
        target_quoted = shlex.quote(target),
        executable_quoted = shlex.quote(executable),
        scripts_shell = " ".join(map(shlex.quote, scripts)))

    spec_file = package_dir / "SPECS" / f"{package_variables['package_name']}.spec"
    with open(template) as handle:
        spec_template = SpecTemplate(handle.read())
    spec_file.write_text(spec_template.substitute(**package_variables))
    if spec_only:
        print(f"spec file {spec_file.resolve()}")
        return

    if format == RPM:
        make_rpm(package_dir, dist_dir, spec_file, package_variables)
    elif format == DEB:
        make_deb(package_dir, dist_dir, spec_file, TEMPLATE_DIR / format, package_variables)
    else:
        raise AssertionError("Unhandled package format '%s'" % format)

if __name__=='__main__':
    parser = argparse.ArgumentParser(
        description='Create an RPM with all dependencies')
    parser.add_argument(
        "-F", "--format",
        default = defaults["format"],
        choices = [RPM, DEB],
        metavar = "TEXT",
        help = "What sort of package to generate [default: %s]" % defaults["format"])
    parser.add_argument(
        "--target",
        default = defaults["target"],
        metavar = "DIR",
        help = "Where the RPM will install the package [default: %s]" % defaults["target"])
    parser.add_argument(
        "--git",
        default = defaults["git"],
        metavar = "BRANCH",
        help = "If not empty check that we are on the given branch and use git --describe to fetch a commit number and append that to the version [default: %s]" % defaults["git"])
    parser.add_argument(
        "--release",
        type=int,
        metavar = "NUMBER",
        help = "RPM Release number. Defaults to 1 more than the currently installed version or 1 if not installed")
    parser.add_argument(
        "--template",
        default = defaults["template"],
        metavar = "TEXT",
        help = "Template to use to generate the spec file [default: %s]" % defaults["template"])
    parser.add_argument(
        "-V", "--vendor",
        default = defaults["vendor"],
        metavar = "TEXT",
        help = "This will become the vendor tag in the RPM [default: %s]" % defaults["vendor"])
    parser.add_argument(
        "--group",
        default = defaults["group"],
        metavar = "TEXT",
        help = "RPM group this package belongs to [default: %s]" % defaults["group"])
    parser.add_argument(
        "--spec-only",
        action = "store_true",
        help = "Only generate spec file")
    parser.add_argument(
        "--version-min",
        default = defaults["version_min"],
        metavar = "TEXT",
        help = "Minimum required version of this program")
    parser.add_argument(
        "--debug",
        action = "store_true",
        help = "Inform about internal actions")
    # The version (1.0.0) will get updated while creating the package
    parser.add_argument('--version', action="version", version=f"%(prog)s {PACKAGE_VERSION}")
    args = vars(parser.parse_args())
    args["executable"] = defaults["executable"]
    if args["debug"]:
        print(f"{args=}")
    full_package(**args)
